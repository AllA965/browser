<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 助手</title>
    <script src="js/marked.min.js"></script>
    <link href="css/github.min.css" rel="stylesheet">
    <script src="js/highlight.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: radial-gradient(circle at top, #fdfdfd 0, #f5f7fb 40%, #f3f4f6 100%);
        }
        #header {
            padding: 12px 14px 8px 14px;
            border-bottom: 1px solid rgba(0,0,0,0.04);
            background: linear-gradient(135deg, rgba(255,255,255,0.96), rgba(246,248,252,0.98));
            backdrop-filter: blur(12px);
        }
        #mode-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            color: #2563eb;
            background: rgba(37,99,235,0.06);
            border: 1px solid rgba(37,99,235,0.12);
        }
        #mode-dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: radial-gradient(circle at 30% 30%, #60a5fa, #2563eb);
        }
        #chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px 14px 14px 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .message {
            max-width: 85%;
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }
        .user-message {
            align-self: flex-end;
            background-color: #0078d4;
            color: white;
            border-bottom-right-radius: 2px;
        }
        .ai-message {
            align-self: flex-start;
            background-color: #ffffff;
            color: #333;
            border-bottom-left-radius: 2px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border: 1px solid #eee;
        }
        .system-message {
            align-self: center;
            background-color: rgba(0,0,0,0.05);
            color: #64748b;
            font-size: 12px;
            padding: 6px 12px;
            border-radius: 999px;
            box-shadow: none;
            border: none;
            margin: 8px 0;
        }
        #input-container {
            padding: 10px 12px 12px 12px;
            background: linear-gradient(to top, rgba(15,23,42,0.04), rgba(255,255,255,0.98));
            border-top: 1px solid rgba(148,163,184,0.35);
            display: flex;
            gap: 10px;
        }
        #user-input {
            flex: 1;
            padding: 10px 11px;
            border: 1px solid rgba(148,163,184,0.7);
            border-radius: 10px;
            outline: none;
            font-size: 14px;
            resize: none;
            height: 40px;
            max-height: 120px;
        }
        #user-input:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 1px rgba(37,99,235,0.06);
        }
        #send-btn {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0 16px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 10px 18px rgba(37,99,235,0.35);
        }
        #send-btn:disabled {
            background: #cbd5f5;
            cursor: not-allowed;
            box-shadow: none;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: #0078d4;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: Consolas, monospace;
            font-size: 13px;
        }
        code {
            font-family: Consolas, monospace;
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
        }
        /* Markdown 表格样式 */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
            font-size: 14px;
        }
        th, td {
            border: 1px solid #e1e4e8;
            padding: 6px 13px;
        }
        th {
            background-color: #f6f8fa;
            font-weight: 600;
        }
        tr:nth-child(2n) {
            background-color: #f8f8f8;
        }
        blockquote {
            margin: 0;
            padding-left: 1em;
            border-left: 4px solid #ddd;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="header">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div id="mode-badge">
                <span id="mode-dot"></span>
                <span id="mode-text">AI 扩展增强模式 · 已就绪</span>
            </div>
            <select id="mode-select" style="font-size: 12px; padding: 4px; border-radius: 4px; border: 1px solid #ccc; background: white;">
                <option value="tool">工具模式 (慢速/可操作)</option>
                <option value="chat">对话模式 (极速/纯文本)</option>
            </select>
        </div>
    </div>
    <div id="chat-container"></div>
    <div id="status-bar" style="display:none; padding: 8px 14px; background: rgba(255,255,255,0.8); backdrop-filter: blur(5px); border-top: 1px solid rgba(0,0,0,0.05); font-size: 12px; color: #64748b; align-items: center; gap: 8px;">
        <div class="loading" style="width: 12px; height: 12px; border-width: 2px;"></div>
        <span id="status-text">正在执行操作...</span>
    </div>
    <div id="input-container">
        <textarea id="user-input" placeholder="输入消息..." rows="1"></textarea>
        <button id="send-btn"><span>发送</span></button>
        <button id="stop-btn" style="display:none; background: #ef4444; color: white; border: none; border-radius: 10px; padding: 0 16px; cursor: pointer; font-weight: bold; font-size: 14px; align-items: center; gap: 4px; box-shadow: 0 10px 18px rgba(239,68,68,0.35);">
            <span>停止</span>
        </button>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const stopBtn = document.getElementById('stop-btn');
        const modeText = document.getElementById('mode-text');
        const statusBar = document.getElementById('status-bar');
        const statusText = document.getElementById('status-text');
        const modeSelect = document.getElementById('mode-select');

        // 监听流式消息
        let currentAiMessageDiv = null;
        let currentFullText = "";

        if (window.chrome && window.chrome.webview) {
            window.chrome.webview.addEventListener('message', event => {
                const data = event.data;
                // data 结构: { type: "chunk"|"start"|"done"|"error", content: "..." }
                
                if (data.type === 'start') {
                    // 开始新消息
                    currentFullText = "";
                    currentAiMessageDiv = addMessage("", 'ai');
                    // 移除 loading 占位符（如果存在）
                    const loadings = document.getElementsByClassName('loading-placeholder');
                    while(loadings.length > 0){
                        loadings[0].parentNode.removeChild(loadings[0]);
                    }
                } else if (data.type === 'chunk') {
                    // 追加内容
                    currentFullText += data.content;
                    if (currentAiMessageDiv) {
                        // 使用 marked 渲染
                        if (typeof marked !== 'undefined') {
                            try {
                                currentAiMessageDiv.innerHTML = marked.parse(currentFullText);
                            } catch {
                                currentAiMessageDiv.innerText = currentFullText;
                            }
                        } else {
                            currentAiMessageDiv.innerText = currentFullText;
                        }
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                    }
                } else if (data.type === 'done') {
                    currentAiMessageDiv = null;
                    // 恢复按钮状态
                    sendBtn.style.display = 'flex';
                    stopBtn.style.display = 'none';
                    sendBtn.disabled = false;
                }
            });
        }

        // 更新状态显示
        let statusTimeout = null;
        function showStatus(text, duration = 3000) {
            if (statusTimeout) {
                clearTimeout(statusTimeout);
                statusTimeout = null;
            }

            if (text) {
                statusText.innerText = text;
                statusBar.style.display = 'flex';
                // 如果设置了时长，则自动隐藏
                if (duration > 0) {
                    statusTimeout = setTimeout(() => {
                        statusBar.style.display = 'none';
                    }, duration);
                }
            } else {
                statusBar.style.display = 'none';
            }
        }

        // 更新模型名称
        window.updateModelName = async function() {
            try {
                if (window.chrome && window.chrome.webview && window.chrome.webview.hostObjects && window.chrome.webview.hostObjects.bridge) {
                    const bridge = window.chrome.webview.hostObjects.bridge;
                    const modelName = await bridge.GetModelName();
                    if (modelName) {
                        modeText.innerText = `自定义 API 模式 · 已连接 ${modelName}`;
                    }
                }
            } catch (error) {
                console.error('Failed to update model name:', error);
            }
        }

        // 页面加载后初始化
        window.addEventListener('DOMContentLoaded', function() {
            window.updateModelName();

            // 配置 marked 和 highlight.js (安全包装)
            if (typeof marked !== 'undefined') {
                try {
                    marked.setOptions({
                        highlight: function(code, lang) {
                            if (typeof hljs !== 'undefined' && lang && hljs.getLanguage(lang)) {
                                return hljs.highlight(code, { language: lang }).value;
                            }
                            if (typeof hljs !== 'undefined') {
                                return hljs.highlightAuto(code).value;
                            }
                            return code;
                        },
                        breaks: true
                    });
                } catch (e) {
                    console.warn('Failed to configure marked:', e);
                }
            }
        });

        function addMessage(text, role) {
            const div = document.createElement('div');
            div.className = `message ${role}-message`;
            
            if (role === 'ai') {
                // 尝试使用 marked 渲染 AI 回复，如果失败则回退到纯文本
                if (typeof marked !== 'undefined') {
                    try {
                        div.innerHTML = marked.parse(text);
                    } catch (e) {
                        console.warn('Markdown parsing failed:', e);
                        div.innerText = text;
                    }
                } else {
                    div.innerText = text;
                }
            } else {
                // 用户消息保持纯文本，防止 XSS，但保留换行
                div.innerText = text;
            }
            
            chatContainer.appendChild(div);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return div;
        }

        async function sendMessage(overrideText = null, silent = false) {
            const text = overrideText || userInput.value.trim();
            if (!text) return;

            if (!overrideText) {
                userInput.value = '';
                userInput.style.height = '40px';
            }
            
            // 清除之前的状态显示
            showStatus(null);
            
            if (!silent) {
                addMessage(text, 'user');
            } else {
                addMessage("正在总结当前网页内容...", 'system');
            }

            // 创建一个临时 loading 消息
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'message ai-message loading-placeholder';
            loadingDiv.innerHTML = '<div class="loading"></div>';
            chatContainer.appendChild(loadingDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            sendBtn.style.display = 'none';
            stopBtn.style.display = 'flex';

            let isStreaming = false;

            try {
                // 调用 C# 注入的对象
                if (window.chrome && window.chrome.webview && window.chrome.webview.hostObjects && window.chrome.webview.hostObjects.bridge) {
                    const bridge = window.chrome.webview.hostObjects.bridge;
                    const mode = modeSelect.value;
                    
                    // 注意：这里是同步等待完整响应。如果需要流式，需要 C# 端支持事件推送。
                    const response = await bridge.CallAiApi(text, mode);
                    
                    if (response === '__STREAMING__') {
                        isStreaming = true;
                        // 流式模式，loadingDiv 会在 'start' 事件中被移除
                        // 按钮状态会在 'done' 事件中恢复
                        return; 
                    }

                    // 移除 loading
                    if (loadingDiv.parentNode) chatContainer.removeChild(loadingDiv);
                    
                    if (response && response.startsWith('__STATUS__:')) {
                        const statusMsg = response.replace('__STATUS__:', '');
                        showStatus(statusMsg);
                        // 状态消息不显示在对话框中
                    } else {
                        // 只有非状态消息才清除状态栏并显示对话
                        showStatus(null);
                        addMessage(response, 'ai');
                    }
                } else {
                    if (loadingDiv.parentNode) chatContainer.removeChild(loadingDiv);
                    addMessage("错误：未找到 API 桥接器。请检查设置。", 'ai');
                }
            } catch (error) {
                if (loadingDiv.parentNode) chatContainer.removeChild(loadingDiv);
                addMessage("错误: " + error.message, 'ai');
            } finally {
                if (!isStreaming) {
                     sendBtn.style.display = 'flex';
                     stopBtn.style.display = 'none';
                     sendBtn.disabled = false;
                     chatContainer.scrollTop = chatContainer.scrollHeight;
                }
            }
        }

        sendBtn.onclick = () => sendMessage();
        
        stopBtn.onclick = async () => {
            try {
                if (window.chrome && window.chrome.webview && window.chrome.webview.hostObjects && window.chrome.webview.hostObjects.bridge) {
                    const bridge = window.chrome.webview.hostObjects.bridge;
                    await bridge.CancelGeneration();
                    showStatus("正在停止...", 0);
                    // 按钮状态会在 sendMessage 的 finally 块中恢复
                }
            } catch (error) {
                console.error("Failed to cancel:", error);
            }
        };

        userInput.onkeydown = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        };

        userInput.oninput = () => {
            userInput.style.height = 'auto';
            userInput.style.height = Math.min(userInput.scrollHeight, 120) + 'px';
        };

        window.setAiPrompt = (prompt, silent = false) => {
            sendMessage(prompt, silent);
        };
    </script>
</body>
</html>
